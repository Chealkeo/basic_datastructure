## 题目描述
输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。

例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

 

示例 1：

输入：n = 12
输出：5
示例 2：

输入：n = 13
输出：6

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
## 代码
```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        #每十个数个位上就有一个1，每100个数十位上就有十个1，每1000个数百位上就有一百个1
        #这个就是temp*base的effect
        #以上是针对整除的情况的，每一步都可能余数不为0，所以通过p=temp%10来得到每一步的余数，由于temp是不断在变的，所以这里的余数其实是不断从低位向高位得到每一位的数字
        #分为余数等于1和大于1的情况，如果余数是1的话，那我们就要考虑当前这个base下有多少1xx,累加的个数就取决于n%base+1；如果余数大于1，说明该位上所有1xx的数据都是包含了的，
        #之所以没有凑够下一个整数级，是因为缺失的是余数后面开头的数。
        #以153为例，有15个10，说明个位上至少有15个1，余数3大于1，说明在150-160的跨度之间151是存在了的，所以个位上的1的个数是15+1。
        #153有1个100（15%10），所以十位上至少有10个1，余数等于5，大于1，说明在100-200之间，11x是全部囊括了的，所以16+10+10=36；
        #1//10=0means153有0个1000，余数是1，说明从0-1000之间的1xx是没有全部囊括的，至于囊括了多少，就是153%100=53，所以是包含了100-153这54个百位上的1.总计36+54=90
        temp = n
        res = 0
        base = 1
        while temp:
            p = temp%10
            temp = temp//10
            res += temp*base
            if p==1:
                res += n% base +1
            elif p>1:
                res += base
            base *= 10
        return res
```
