## 背包问题
背包问题主要是指给出一系列物品，每个物品有消耗和价值两个属性，消耗背包的容量，增加背包的价值。  
## 问题类型
主要有这么几种类型，0-1背包、完全背包和多重背包问题，这两类问题的区别在于每件物品是否是有限的，如果每件物品是无限可取用的，那么就是完全背包问题，  
这些背包问题的状态转移方程关键在于判断dp[i][j]对应的值是取决于`dp[i-1]对应的当前状态值dp[i-1][j]和dp[i-1]对应的其他状态值dp[i-1][j-c[i]]+v[i]`还是  
`dp[i-1]对应的当前状态值dp[i-1][j]和dp[i]对应的其他状态值dp[i][j-c[i]]+v[i]`这也决定了在进行容量遍历时是采取`正向枚举`还是`逆向枚举`:  
```python
dp = [0] * (m+1)
#0-1背包问题，容量逆向枚举，这次选择取用第i种物品，要确保计算前i件物品的最大价值dp[j]时的时候我们用到的dp数组里的dp[j-1]是前i-1件物品时的状态，所以要从后往前计算。  
for i in range(1,n+1):
    for j in range(m,ci-1,-1):
        dp[j] = max(dp[j],dp[j-ci]+v[i])
        
#完全背包问题，容量正向枚举，第i件物品取用与否，与之前是否被取用无关，所以要考虑的是dp[i]对应的其他状态。
#dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i]), j≥w[i]
for i in range(1,n+1):
    for j in range(ci,m+1):
        dp[j] = max(dp[j],dp[j-c[i]]+v[i])


#多重背包问题，容量逆向枚举，取用个数受给定的数目和总体容量除以该物品的重量。
#dp[i][j] = max((dp[i - 1][j - h * w[i]] + h * v[i]) for every h)
    for j in range(m,c[i]-1,-1)
        for h in range(0,min(h[i],m//ci)):
            dp[j] = max(dp[j],dp[j-h*ci]+h*vi)
            
return dp[m]
```
## 需求不同导致的初始化不同
有的题目要求恰好把背包装满，有的题目则没有必须装满背包的要求。  
如果是前者，背包必须恰好装满，那么在初始化的时候，除了dp[0] = 0, 其他都应该初始化为'-inf'或False。  
如果是后者，背包可以不装满，那么在初始化的时候至少每个背包都可以什么都不装，价值为0，所以均初始化为0，dp = [0] * (m+1)  
  
`如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，  
属于未定义的状态，应该被赋值为 -∞ 了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0，所以初始时状态的值也就全部为 0了。`


## 完全背包问题和多重背包问题的转化
任意一个正整数可以表示为一些2的幂次的和。  
第i种物品最多选择k = V/C[i]件，这c[i]件可以表示为1，2，4，...，k- logk + 1, 件的组合，系数成到该物品的重量和价值上，就转换成了0-1背包问题。  
多重背包问题同理，k = min(v/c[i], count[i])。  

## 二维费用的背包问题
二维背包是指物品的花销分为了两个维度，dp[i][j][k] 表示选择前i件物品时付出两个维度的花销分别为[j][k]时所能获得的最大价值。  
空间优化后，可以只选择二维的数组，若每件物品只可取用一次，则采用j、k的逆序循环；当物品都是无限次可取用时选择顺序循环，如果是多重背包，可拆分物品。  

## 更多问题见背包问题九讲
